#!/usr/bin/env python

# Import modules
import rospy
import message_filters ### ADD THIS
import pcl
import sensor_msgs.point_cloud2 as pc2
from sensor_msgs.msg import PointCloud2
from sensor_msgs.msg import Image
from std_msgs.msg import String
from cv_bridge import CvBridge, CvBridgeError
from arm_msgs.msg import ManipulatorState
import roslib; roslib.load_manifest('robotiq_2f_gripper_control')
from robotiq_2f_gripper_control.msg import _Robotiq2FGripper_robot_input  as inputMsg
# from robotiq_2f_gripper_control.msg import Robotiq2FGripper_robot_input
import rosbag

import cv2
import numpy as np

# import open3d as o3d

# Instantiate CvBridge
bridge = CvBridge()


#------Start of Class
class Data:
    def __init__(self):
        self.bridge = CvBridge()

        # self.color = message_filters.Subscriber('/camera/color/image_raw', Image)
        # self.depth = message_filters.Subscriber('/camera/aligned_depth_to_color/image_raw', Image)
        # self.pcl = message_filters.Subscriber('/camera/depth_registered/points', PointCloud2)
        # self.arm_state = message_filters.Subscriber('/ur_hardware_interface/arm_state', ManipulatorState)
        # # self.gripper = rospy.Subscriber("Robotiq2FGripperRobotInput", inputMsg.Robotiq2FGripper_robot_input, self.printStatus)
        # self.gripper = message_filters.Subscriber('/Robotiq2FGripperRobotInput', inputMsg.Robotiq2FGripper_robot_input)

        self.color = message_filters.Subscriber('/throttle/rgb', Image)
        self.depth = message_filters.Subscriber('/throttle/depth', Image)
        self.pcl = message_filters.Subscriber('/throttle/pcl', PointCloud2)
        self.arm_state = message_filters.Subscriber('/throttle/arm_state', ManipulatorState)
        self.gripper = message_filters.Subscriber('/throttle/gripper', inputMsg.Robotiq2FGripper_robot_input)

    def ros_to_pcl(self, ros_cloud):
        """ Converts a ROS PointCloud2 message to a pcl PointXYZRGB
        
            Args:
                ros_cloud (PointCloud2): ROS PointCloud2 message
                
            Returns:
                pcl.PointCloud_PointXYZRGB: PCL XYZRGB point cloud
        """
        points_list = []

        for data in pc2.read_points(ros_cloud, skip_nans=True):
            points_list.append([data[0], data[1], data[2], data[3]])

        pcl_data = pcl.PointCloud_PointXYZRGB()
        pcl_data.from_list(points_list)

        return pcl_data

    def printStatus(self, status):
        """Print the status string generated by the statusInterpreter function."""

        print(self.gripperStatusInterpreter(status))

    def gripperStatusInterpreter(self, status):
        """Generate a string according to the current value of the status variables."""

        output = '\n-----\n2F gripper status interpreter\n-----\n'

        #gACT
        output += 'gACT = ' + str(status.gACT) + ': '
        if(status.gACT == 0):
            output += 'Gripper reset\n'
        if(status.gACT == 1):
            output += 'Gripper activation\n'

        #gGTO
        output += 'gGTO = ' + str(status.gGTO) + ': '
        if(status.gGTO == 0):
            output += 'Standby (or performing activation/automatic release)\n'
        if(status.gGTO == 1):
            output += 'Go to Position Request\n'

        #gSTA
        output += 'gSTA = ' + str(status.gSTA) + ': '
        if(status.gSTA == 0):
            output += 'Gripper is in reset ( or automatic release ) state. see Fault Status if Gripper is activated\n'
        if(status.gSTA == 1):
            output += 'Activation in progress\n'
        if(status.gSTA == 2):
            output += 'Not used\n'
        if(status.gSTA == 3):
            output += 'Activation is completed\n'

        #gOBJ
        output += 'gOBJ = ' + str(status.gOBJ) + ': '
        if(status.gOBJ == 0):
            output += 'Fingers are in motion (only meaningful if gGTO = 1)\n'
        if(status.gOBJ == 1):
            output += 'Fingers have stopped due to a contact while opening\n'
        if(status.gOBJ == 2):
            output += 'Fingers have stopped due to a contact while closing \n'
        if(status.gOBJ == 3):
            output += 'Fingers are at requested position\n'
    
        #gFLT
        output += 'gFLT = ' + str(status.gFLT) + ': '
        if(status.gFLT == 0x00):
            output += 'No Fault\n'
        if(status.gFLT == 0x05):
            output += 'Priority Fault: Action delayed, initialization must be completed prior to action\n'
        if(status.gFLT == 0x07):
            output += 'Priority Fault: The activation bit must be set prior to action\n'
        if(status.gFLT == 0x09):
            output += 'Minor Fault: The communication chip is not ready (may be booting)\n'   
        if(status.gFLT == 0x0B):
            output += 'Minor Fault: Automatic release in progress\n'
        if(status.gFLT == 0x0E):
            output += 'Major Fault: Overcurrent protection triggered\n'
        if(status.gFLT == 0x0F):
            output += 'Major Fault: Automatic release completed\n'

        #gPR
        output += 'gPR = ' + str(status.gPR) + ': '
        output += 'Echo of the requested position for the Gripper: ' + str(status.gPR) + '/255\n'

        #gPO
        output += 'gPO = ' + str(status.gPO) + ': '
        output += 'Position of Fingers: ' + str(status.gPO) + '/255\n'

        #gCU
        output += 'gCU = ' + str(status.gCU) + ': '
        output += 'Current of Fingers: ' + str(status.gCU * 10) + ' mA\n'   

        return output
        

    def callback(self,rgb, depth, pcl, arm_state, gripper_state):
        print("start callback")
        
        cv_image_rgb = self.bridge.imgmsg_to_cv2(rgb, desired_encoding='passthrough')
        cv_image_depth = self.bridge.imgmsg_to_cv2(depth, desired_encoding='passthrough')
        # cloud = self.ros_to_pcl(pcl)

        # if not depth_frame or not color_frame:
        #     continue

        # # Convert images to numpy arrays
        # depth_image = np.asanyarray(depth_frame.get_data())
        # color_image = np.asanyarray(color_frame.get_data())

        # # Apply colormap on depth image (image must be converted to 8-bit per pixel first)
        depth_colormap = cv2.applyColorMap(cv2.convertScaleAbs(cv_image_depth, alpha=0.03), cv2.COLORMAP_JET)

        depth_colormap_dim = cv_image_depth.shape
        color_colormap_dim = cv_image_rgb.shape

        # If depth and color resolutions are different, resize color image to match depth image for display
        if depth_colormap_dim != color_colormap_dim:
            resized_color_image = cv2.resize(cv_image_rgb, dsize=(depth_colormap_dim[1], depth_colormap_dim[0]), interpolation=cv2.INTER_AREA)
            images = np.hstack((resized_color_image, depth_colormap))
        else:
            images = np.hstack((cv_image_rgb, depth_colormap))

        # o3d.visualization.draw_plotly([pcl], window_name='Original point cloud')

        cv2.imshow("Realsense Camera", images)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            rospy.signal_shutdown('Quit')
            cv2.destroyAllWindows()
        
        self.printStatus(self.gripper)

        # write to bag
        global bag
        bag.write('rgb', cv_image_rgb)
        bag.write('depth', depth_colormap)
        bag.write('pcl', pcl)
        bag.write('arm_state', arm_state)
        bag.write('gripper_state', gripper_state)

        print("complete callback")

def main():
    bag = rosbag.Bag('RosBagTest1.bag', 'w')
    data = Data()
    rospy.init_node('save_data', anonymous=True)
    try:
        # put some conditions to take only synchronized msgs from the different topics
        ts = message_filters.ApproximateTimeSynchronizer([data.color, data.depth, data.pcl, data.arm_state, data.gripper], queue_size=10, slop=0.06)  # hz is approx 29 for images.. 17 for pcl
        # ts = message_filters.TimeSynchronizer([data.color, data.depth, data.pcl, data.arm_state, data.gripper], queue_size=10)
        print("test1")
        # "slop" parameter in the constructor that defines the delay (in seconds) with which messages can be synchronized
        # only in case of synchronized data, callback
        
        ts.registerCallback(data.callback)
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")

if __name__ == '__main__':
    main()
